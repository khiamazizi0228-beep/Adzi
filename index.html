<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Green-Guy (Reference Look)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#6a4527;}
    canvas{display:block;}
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ---------- TUNING (wenn du später feinjustieren willst) ---------- */
const FACE = {
  eyeY: 0.40,      // 0..1 in texture (höher = weiter oben)
  eyeGap: 0.16,    // Abstand der Augen
  eyeR: 0.075,     // Augenradius
  eyeStroke: 0.050,// Strichdicke

  smileY: 0.58,
  smileR: 0.165,
  smileStroke: 0.055
};

const COLORS = {
  bg: 0x6a4527,
  green: "#22c55e",
  greenHex: 0x22c55e,
  face: "#0b0b0b"
};

/* ---------- Scene ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(COLORS.bg);
scene.fog = new THREE.Fog(COLORS.bg, 7.5, 16.5);

/* ---------- Camera (portrait framing like your image) ---------- */
const camera = new THREE.PerspectiveCamera(38, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.45, 3.9);

/* ---------- Renderer ---------- */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ---------- Lights (studio soft) ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.55));

const key = new THREE.DirectionalLight(0xffffff, 1.05);
key.position.set(3.2, 4.2, 2.0);
scene.add(key);

const fill = new THREE.DirectionalLight(0xffffff, 0.35);
fill.position.set(-3.5, 2.0, 1.2);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.45);
rim.position.set(0.0, 2.6, -3.5);
scene.add(rim);

/* ---------- Face Textures (ColorMap + BumpMap) ---------- */
function makeFaceTextures(size = 1024){
  // Color map: green base + black face lines
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");

  // base
  ctx.fillStyle = COLORS.green;
  ctx.fillRect(0,0,size,size);

  // face
  ctx.strokeStyle = COLORS.face;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  const eyeY = size * FACE.eyeY;
  const eyeR = size * FACE.eyeR;
  const eyeGap = size * FACE.eyeGap;
  const eyeStroke = size * FACE.eyeStroke;

  ctx.lineWidth = eyeStroke;
  // left eye (half arc)
  ctx.beginPath();
  ctx.arc(size*0.5 - eyeGap, eyeY, eyeR, Math.PI, 0, false);
  ctx.stroke();
  // right eye
  ctx.beginPath();
  ctx.arc(size*0.5 + eyeGap, eyeY, eyeR, Math.PI, 0, false);
  ctx.stroke();

  const smileY = size * FACE.smileY;
  const smileR = size * FACE.smileR;
  const smileStroke = size * FACE.smileStroke;

  ctx.lineWidth = smileStroke;
  ctx.beginPath();
  ctx.arc(size*0.5, smileY, smileR, 0.15*Math.PI, 0.85*Math.PI, false);
  ctx.stroke();

  const colorTex = new THREE.CanvasTexture(c);
  colorTex.colorSpace = THREE.SRGBColorSpace;

  // Bump map: mid-gray base; darker lines = engraved
  const b = document.createElement("canvas");
  b.width = b.height = size;
  const bctx = b.getContext("2d");

  bctx.fillStyle = "rgb(128,128,128)";
  bctx.fillRect(0,0,size,size);

  // soft “dent” pass 1 (wider)
  bctx.strokeStyle = "rgb(85,85,85)";
  bctx.lineCap = "round";
  bctx.lineJoin = "round";

  bctx.lineWidth = eyeStroke * 1.25;
  bctx.beginPath();
  bctx.arc(size*0.5 - eyeGap, eyeY, eyeR, Math.PI, 0, false);
  bctx.stroke();
  bctx.beginPath();
  bctx.arc(size*0.5 + eyeGap, eyeY, eyeR, Math.PI, 0, false);
  bctx.stroke();

  bctx.lineWidth = smileStroke * 1.20;
  bctx.beginPath();
  bctx.arc(size*0.5, smileY, smileR, 0.15*Math.PI, 0.85*Math.PI, false);
  bctx.stroke();

  // soft “dent” pass 2 (sharper center)
  bctx.strokeStyle = "rgb(65,65,65)";
  bctx.lineWidth = eyeStroke * 0.95;
  bctx.beginPath();
  bctx.arc(size*0.5 - eyeGap, eyeY, eyeR, Math.PI, 0, false);
  bctx.stroke();
  bctx.beginPath();
  bctx.arc(size*0.5 + eyeGap, eyeY, eyeR, Math.PI, 0, false);
  bctx.stroke();

  bctx.lineWidth = smileStroke * 0.95;
  bctx.beginPath();
  bctx.arc(size*0.5, smileY, smileR, 0.15*Math.PI, 0.85*Math.PI, false);
  bctx.stroke();

  const bumpTex = new THREE.CanvasTexture(b);
  bumpTex.colorSpace = THREE.SRGBColorSpace;

  return { colorTex, bumpTex };
}

const { colorTex, bumpTex } = makeFaceTextures(1024);

/* ---------- Materials ---------- */
const headMat = new THREE.MeshPhysicalMaterial({
  map: colorTex,
  bumpMap: bumpTex,
  bumpScale: -0.07,              // NEGATIV = “eingedrückt”
  roughness: 0.62,
  metalness: 0.02,
  sheen: 0.18,
  sheenRoughness: 0.75
});

const bodyMat = new THREE.MeshPhysicalMaterial({
  color: COLORS.greenHex,
  roughness: 0.64,
  metalness: 0.02,
  sheen: 0.18,
  sheenRoughness: 0.78
});

/* ---------- Build Green-Guy (Sphere+Stretch = clean UVs) ---------- */
const guy = new THREE.Group();
scene.add(guy);

// HEAD: sphere stretched to look like capsule
const headGeo = new THREE.SphereGeometry(1.0, 128, 128);
const head = new THREE.Mesh(headGeo, headMat);
head.scale.set(1.0, 1.28, 1.0);      // “capsule” look
head.position.set(0, 1.08, 0);
guy.add(head);

// NECK
const neck = new THREE.Mesh(
  new THREE.CylinderGeometry(0.42, 0.58, 0.50, 96),
  bodyMat
);
neck.position.set(0, 0.28, 0);
neck.rotation.x = 0.08;
guy.add(neck);

// TORSO: soft shoulders like your render
const torso = new THREE.Mesh(new THREE.SphereGeometry(1.55, 128, 128), bodyMat);
torso.scale.set(1.25, 0.68, 1.15);
torso.position.set(0, -0.86, 0);
guy.add(torso);

/* ---------- Animation (very subtle) ---------- */
const clock = new THREE.Clock();
function animate(){
  const t = clock.getElapsedTime();

  guy.position.y = Math.sin(t * 1.05) * 0.035;
  torso.scale.y = 0.68 + Math.sin(t * 1.7) * 0.008;
  guy.rotation.y = Math.sin(t * 0.45) * 0.055;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ---------- Resize ---------- */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>