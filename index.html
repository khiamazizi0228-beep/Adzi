<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Green-Guy (Correct Face Front)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#6a4527;}
    canvas{display:block;}
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* ---------- Scene / Camera / Renderer ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x6a4527);

const camera = new THREE.PerspectiveCamera(38, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.45, 3.9);
camera.lookAt(0, 1.05, 0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ---------- Lights (soft studio) ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.55));

const key = new THREE.DirectionalLight(0xffffff, 1.05);
key.position.set(3.2, 4.2, 2.0);
scene.add(key);

const fill = new THREE.DirectionalLight(0xffffff, 0.35);
fill.position.set(-3.5, 2.0, 1.2);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.45);
rim.position.set(0.0, 2.6, -3.5);
scene.add(rim);

/* ---------- Face texture generator (color + bump) ---------- */
const FACE = {
  eyeY: 0.40,
  eyeGap: 0.16,
  eyeR: 0.075,
  eyeStroke: 0.050,
  smileY: 0.58,
  smileR: 0.165,
  smileStroke: 0.055
};

function makeFaceTextures(size = 1024){
  // Color
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");

  ctx.fillStyle = "#22c55e";
  ctx.fillRect(0,0,size,size);

  ctx.strokeStyle = "#0b0b0b";
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  const eyeY = size * FACE.eyeY;
  const eyeR = size * FACE.eyeR;
  const eyeGap = size * FACE.eyeGap;
  const eyeStroke = size * FACE.eyeStroke;

  ctx.lineWidth = eyeStroke;
  ctx.beginPath(); ctx.arc(size*0.5 - eyeGap, eyeY, eyeR, Math.PI, 0, false); ctx.stroke();
  ctx.beginPath(); ctx.arc(size*0.5 + eyeGap, eyeY, eyeR, Math.PI, 0, false); ctx.stroke();

  const smileY = size * FACE.smileY;
  const smileR = size * FACE.smileR;
  const smileStroke = size * FACE.smileStroke;

  ctx.lineWidth = smileStroke;
  ctx.beginPath(); ctx.arc(size*0.5, smileY, smileR, 0.15*Math.PI, 0.85*Math.PI, false); ctx.stroke();

  const colorTex = new THREE.CanvasTexture(c);
  colorTex.colorSpace = THREE.SRGBColorSpace;

  // Bump (engraved look)
  const b = document.createElement("canvas");
  b.width = b.height = size;
  const bctx = b.getContext("2d");
  bctx.fillStyle = "rgb(128,128,128)";
  bctx.fillRect(0,0,size,size);

  bctx.lineCap = "round";
  bctx.lineJoin = "round";

  const dent = (strokeMul, col) => {
    bctx.strokeStyle = col;
    bctx.lineWidth = eyeStroke * strokeMul;
    bctx.beginPath(); bctx.arc(size*0.5 - eyeGap, eyeY, eyeR, Math.PI, 0, false); bctx.stroke();
    bctx.beginPath(); bctx.arc(size*0.5 + eyeGap, eyeY, eyeR, Math.PI, 0, false); bctx.stroke();

    bctx.lineWidth = smileStroke * strokeMul;
    bctx.beginPath(); bctx.arc(size*0.5, smileY, smileR, 0.15*Math.PI, 0.85*Math.PI, false); bctx.stroke();
  };
  dent(1.25, "rgb(85,85,85)");
  dent(0.95, "rgb(65,65,65)");

  const bumpTex = new THREE.CanvasTexture(b);
  bumpTex.colorSpace = THREE.SRGBColorSpace;

  return { colorTex, bumpTex };
}

const { colorTex, bumpTex } = makeFaceTextures(1024);

/* âœ… THE FIX: rotate the texture around its center so the face is FRONT */
const FACE_ROT = -Math.PI / 2; // <-- if somehow still off, try +Math.PI/2
for (const tex of [colorTex, bumpTex]) {
  tex.center.set(0.5, 0.5);
  tex.rotation = FACE_ROT;
  tex.needsUpdate = true;
}

/* ---------- Materials ---------- */
const headMat = new THREE.MeshPhysicalMaterial({
  map: colorTex,
  bumpMap: bumpTex,
  bumpScale: -0.07,        // negative = engraved
  roughness: 0.62,
  metalness: 0.02,
  sheen: 0.18,
  sheenRoughness: 0.75
});

const bodyMat = new THREE.MeshPhysicalMaterial({
  color: 0x22c55e,
  roughness: 0.64,
  metalness: 0.02,
  sheen: 0.18,
  sheenRoughness: 0.78
});

/* ---------- Build Green-Guy (stable UV: Sphere + Stretch) ---------- */
const guy = new THREE.Group();
scene.add(guy);

// Head (sphere stretched like capsule, UV stays correct)
const headGeo = new THREE.SphereGeometry(1.0, 128, 128);
const head = new THREE.Mesh(headGeo, headMat);
head.scale.set(1.0, 1.28, 1.0);
head.position.set(0, 1.08, 0);
guy.add(head);

// Neck
const neck = new THREE.Mesh(
  new THREE.CylinderGeometry(0.42, 0.58, 0.50, 96),
  bodyMat
);
neck.position.set(0, 0.28, 0);
neck.rotation.x = 0.08;
guy.add(neck);

// Torso
const torso = new THREE.Mesh(new THREE.SphereGeometry(1.55, 128, 128), bodyMat);
torso.scale.set(1.25, 0.68, 1.15);
torso.position.set(0, -0.86, 0);
guy.add(torso);

/* ---------- Animation (subtle) ---------- */
const clock = new THREE.Clock();
function animate(){
  const t = clock.getElapsedTime();
  guy.position.y = Math.sin(t * 1.05) * 0.035;
  torso.scale.y = 0.68 + Math.sin(t * 1.7) * 0.008;
  guy.rotation.y = Math.sin(t * 0.45) * 0.055;
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ---------- Resize ---------- */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>