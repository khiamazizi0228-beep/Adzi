<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Green-Guy (3D)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#6a4527;}
    canvas{display:block;}
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

// ---------- Scene ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x6a4527);

// Camera
const camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.55, 5.3);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ---------- Soft "studio" lighting ----------
scene.add(new THREE.AmbientLight(0xffffff, 0.55));

const key = new THREE.DirectionalLight(0xffffff, 1.05);
key.position.set(3.2, 4.2, 2.2);
scene.add(key);

const fill = new THREE.DirectionalLight(0xffffff, 0.35);
fill.position.set(-3.5, 2.0, 1.5);
scene.add(fill);

// Rim light from behind (gives that rendered edge)
const rim = new THREE.DirectionalLight(0xffffff, 0.45);
rim.position.set(0.0, 2.5, -3.5);
scene.add(rim);

// ---------- Tiny procedural texture (subtle render grain) ----------
function makeNoiseTexture(size = 256) {
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(size, size);
  for (let i = 0; i < img.data.length; i += 4) {
    const v = 120 + Math.random() * 40; // subtle mid noise
    img.data[i] = v;
    img.data[i+1] = v;
    img.data[i+2] = v;
    img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2, 2);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}
const noiseTex = makeNoiseTexture();

// ---------- Materials ----------
const greenMat = new THREE.MeshPhysicalMaterial({
  color: 0x22c55e,
  roughness: 0.62,
  metalness: 0.02,
  clearcoat: 0.0,
  sheen: 0.2,
  sheenRoughness: 0.7
});
// add subtle grain via roughnessMap-like trick: use as map with low intensity via onBeforeCompile? too heavy.
// simpler: use as map and reduce effect by mixing color—kept minimal:
greenMat.map = null;

const faceMat = new THREE.MeshStandardMaterial({
  color: 0x0c0c0c,
  roughness: 0.95,
  metalness: 0.0
});

// ---------- Green-Guy Group ----------
const guy = new THREE.Group();
scene.add(guy);

// Helper: capsule mesh (like your head)
function makeCapsule(radius = 1, height = 1.2, segments = 64) {
  // CapsuleGeometry exists in newer three versions, but to be safe we build it using CapsuleGeometry if available:
  if (THREE.CapsuleGeometry) {
    return new THREE.CapsuleGeometry(radius, height, segments, segments);
  }
  // fallback: use Cylinder + two spheres merged visually (group)
  // (we won't use fallback here because unpkg version supports CapsuleGeometry)
  return new THREE.CapsuleGeometry(radius, height, segments, segments);
}

// HEAD (capsule, smooth)
const headGeo = makeCapsule(1.0, 1.05, 24);
const head = new THREE.Mesh(headGeo, greenMat);
head.position.set(0, 1.05, 0);
head.scale.set(1.0, 1.05, 1.0);
guy.add(head);

// NECK (smooth transition)
const neck = new THREE.Mesh(
  new THREE.CylinderGeometry(0.42, 0.55, 0.45, 64),
  greenMat
);
neck.position.set(0, 0.28, 0);
neck.rotation.x = 0.08;
guy.add(neck);

// TORSO (soft shoulders like reference)
const torso = new THREE.Mesh(new THREE.SphereGeometry(1.45, 64, 64), greenMat);
torso.scale.set(1.2, 0.70, 1.1);
torso.position.set(0, -0.78, 0);
guy.add(torso);

// ---------- FACE (embedded look) ----------
// Trick: place the face geometry *slightly inside* the head surface.
// That makes it look like "engraved", not sticker.

const faceGroup = new THREE.Group();
head.add(faceGroup);

// position face group towards camera (front of head)
faceGroup.position.set(0, 0.05, 0.98);
faceGroup.rotation.x = -0.10; // matches head curvature a bit

// Eye: half-arc using TorusGeometry segment
function makeEye(x) {
  const geo = new THREE.TorusGeometry(0.23, 0.055, 20, 80, Math.PI);
  const eye = new THREE.Mesh(geo, faceMat);
  eye.rotation.x = Math.PI / 2;      // stand it up
  eye.rotation.z = Math.PI;          // flip to become ∩
  eye.position.set(x, 0.10, -0.04);  // slightly INSIDE (negative z within faceGroup)
  return eye;
}

const leftEye = makeEye(-0.36);
const rightEye = makeEye(0.36);
faceGroup.add(leftEye, rightEye);

// Smile: larger half-arc
const smileGeo = new THREE.TorusGeometry(0.48, 0.060, 22, 90, Math.PI);
const smile = new THREE.Mesh(smileGeo, faceMat);
smile.rotation.x = Math.PI / 2;
smile.position.set(0, -0.36, -0.04); // slightly INSIDE
faceGroup.add(smile);

// Optional: soften face even more by tiny scale
faceGroup.scale.set(1.0, 1.0, 1.0);

// ---------- Camera framing / subtle fog for render vibe ----------
scene.fog = new THREE.Fog(0x6a4527, 7.5, 16.5);

// ---------- Animation (gentle like your image) ----------
const clock = new THREE.Clock();
function animate(){
  const t = clock.getElapsedTime();

  // very subtle breathing and micro turn
  guy.position.y = Math.sin(t * 1.1) * 0.04;
  torso.scale.y = 0.70 + Math.sin(t * 1.8) * 0.01;

  // small friendly sway
  guy.rotation.y = Math.sin(t * 0.45) * 0.06;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// Resize
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>